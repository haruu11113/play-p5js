//=============================================================================
// Shader-Tyoimaru - フラグメントシェーダー
// 滑らかな曲線を持つ動的な3Dオブジェクトの色彩効果を生成する
//=============================================================================

precision mediump float;

//-----------------------------------------------------------------------------
// 定数
//-----------------------------------------------------------------------------
#define PI 3.14159265359
#define TWO_PI 6.28318530718

//-----------------------------------------------------------------------------
// ユニフォームと変数
//-----------------------------------------------------------------------------
varying vec3 vNormal;    // 頂点シェーダーから受け取る法線ベクトル
uniform float uTime;     // 経過時間（秒）

//-----------------------------------------------------------------------------
// 色彩制御パラメータ
//-----------------------------------------------------------------------------
// 基本色彩パラメータ
const float BASE_HUE = 0.7;          // 基本色相（青〜紫）
const float HUE_VARIATION = 0.3;     // 色相のノイズによる変化量
const float HUE_TIME_FACTOR = 0.1;   // 色相の時間による変化量
const float TIME_SPEED = 0.2;        // ノイズの時間変化速度

// エッジ効果パラメータ
const float EDGE_POWER = 2.0;        // エッジ強調の強さ
const float EDGE_MIX = 0.5;          // エッジハイライトの混合率

// 脈動効果パラメータ
const float PULSE_AMPLITUDE = 0.05;  // 脈動の強さ
const float PULSE_SPEED = 2.0;       // 脈動の速度

//=============================================================================
// ユーティリティ関数
//=============================================================================

/**
 * 乱数生成関数
 * @param {vec2} st - 2次元シード値
 * @return {float} 0.0〜1.0の乱数値
 */
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

/**
 * 2Dノイズ関数
 * @param {vec2} st - サンプリング座標
 * @return {float} 0.0〜1.0のノイズ値
 */
float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    
    // 四隅の乱数値
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    
    // 三次エルミート曲線による補間
    vec2 u = f * f * (3.0 - 2.0 * f);
    
    // バイリニア補間
    float ab = mix(a, b, u.x);
    float cd = mix(c, d, u.x);
    return mix(ab, cd, u.y);
}

/**
 * HSVからRGBへの変換関数
 * @param {vec3} c - HSV色空間の値（x:色相, y:彩度, z:明度）
 * @return {vec3} RGB色空間の値
 */
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

//=============================================================================
// 色彩計算関数
//=============================================================================

/**
 * エッジ検出関数
 * 法線ベクトルの変化に基づいてエッジを検出する
 * @param {vec3} normal - 法線ベクトル（正規化済み）
 * @return {float} エッジの強度（0.0〜1.0）
 */
float calculateEdge(vec3 normal) {
    // Z方向との角度差に基づくエッジ検出
    float edge = 1.0 - abs(dot(normal, vec3(0.0, 0.0, 1.0)));
    
    // エッジをより鮮明にするためにべき乗
    return pow(edge, EDGE_POWER);
}

/**
 * 時間変化するノイズ値の計算
 * @param {vec2} seed - ノイズのシード値
 * @return {float} 時間変化するノイズ値（0.0〜1.0）
 */
float calculateTimeNoise(vec2 seed) {
    return noise(seed + vec2(uTime * TIME_SPEED));
}

/**
 * 色相の計算
 * 基本色相にノイズと時間による変化を加える
 * @param {float} noiseValue - ノイズ値（0.0〜1.0）
 * @return {float} 最終的な色相値（0.0〜1.0）
 */
float calculateHue(float noiseValue) {
    return BASE_HUE + 
           HUE_VARIATION * noiseValue + 
           HUE_TIME_FACTOR * sin(uTime * 0.5);
}

/**
 * 脈動効果の計算
 * 時間に基づく色の脈動を生成する
 * @return {vec3} 脈動による色の変化量
 */
vec3 calculatePulse() {
    float pulse = PULSE_AMPLITUDE * sin(uTime * PULSE_SPEED);
    return pulse * vec3(0.5, 0.0, 0.5); // 紫色の脈動
}

//=============================================================================
// メイン関数
//=============================================================================

void main() {
    //-------------------------------------------------------------------------
    // 1. 法線ベクトルの準備
    //-------------------------------------------------------------------------
    // 法線ベクトルを正規化
    vec3 normal = normalize(vNormal);
    
    // 法線ベクトルをカラー空間に変換（0〜1の範囲）
    vec3 normalColor = normal * 0.5 + 0.5;
    
    //-------------------------------------------------------------------------
    // 2. ノイズと特殊効果の計算
    //-------------------------------------------------------------------------
    // ノイズのシード値を生成
    vec2 noiseSeed = normal.xy * 3.0;
    
    // 時間変化するノイズ値を計算
    float noiseValue = calculateTimeNoise(noiseSeed);
    
    // エッジを検出
    float edge = calculateEdge(normal);
    
    //-------------------------------------------------------------------------
    // 3. HSVカラーの計算
    //-------------------------------------------------------------------------
    // HSVカラーの各成分を計算
    float hue = calculateHue(noiseValue);
    float saturation = 0.6 + 0.4 * edge; // エッジで彩度を上げる
    float value = 0.7 + 0.3 * normalColor.y; // 明度は法線のY成分に基づく
    
    // HSVからRGBに変換
    vec3 color = hsv2rgb(vec3(hue, saturation, value));
    
    //-------------------------------------------------------------------------
    // 4. 特殊効果の適用
    //-------------------------------------------------------------------------
    // エッジに基づいて色を調整（エッジを強調）
    color = mix(color, vec3(1.0), edge * EDGE_MIX);
    
    // 時間に基づく脈動効果を追加
    color += calculatePulse();
    
    //-------------------------------------------------------------------------
    // 5. 最終出力
    //-------------------------------------------------------------------------
    // 最終的な色を設定
    gl_FragColor = vec4(color, 1.0);
}
